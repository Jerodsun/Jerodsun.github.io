<!DOCTYPE html>
<html>
<head>
  <!-- This website is Copyright Jerod Sun, 2019. -->
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>String Search Algorithms.</title>
<meta name="description" content="Personal Website">

<link rel="stylesheet" href="/css/main.css">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" >
<link rel="canonical" href="jerodsun.github.io/explainer/">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-136819184-1', 'auto');
  ga('send', 'pageview');
</script>


</head>
<body>
  <header class="site-header">
  <div class="container">
    <input type="checkbox" id="toggleNavbar">
    <h1 class="logo"><a href="/">Jerod <span>Sun</span></a></h1>
    <label for="toggleNavbar" role="button" class="toggle-navbar-button">
      <i class="icon icon-menu"></i>
      <i class="icon icon-cross"></i>
    </label>
    <nav class="navbar">
      <ul>
        <li><a href="/" title="Home">Home</a></li>
        
          <li><a href="/about" title="About">About</a></li>
        
        <li><a href="https://drive.google.com/file/d/1NtMNuN__pY6wmqzsY9pn6a-fGpN_2Txi/" title="Resume">Resume</a></li>
      </ul>
    </nav>
  </div>
</header>



<main class="main-container">
  <div class="container">
    <article role="article" class="page card">

  <header class="post-header">
    <h1 class="post-title">String Search Algorithms.</h1>
  </header>

  <div class="post-content">
    <h2 id="what-are-they-and-how-do-they-work">What are they and how do they work?</h2>

<p>Start typing the name of a person you want to text on your phone. Search “cat gifs” in Google. Find the word “perspicuity” in an essay. Do you expect instantaneous results?</p>

<p><br /></p>
<center>
       <img src="/images/explainer/cat_computer.jpg" width="640" height="360" />
   </center>
<p><br /></p>

<p>These things happen so fast that we don’t even think about them. But what is behind all of these actions? What allows us to interact with the millions of micro-pulses sent by circuits to a screen-based interface?</p>

<p>Let’s start by reviewing what these micro-pulses are and how they work to display images on a screen.</p>

<h3 id="the-basics">The basics:</h3>

<p>When you interact with your computer, your input is converted to instructions in zeros and ones - bits and bytes.</p>

<p>These bits and bytes then reach the central processing unit - the CPU. The CPU takes your instructions, and executes them.</p>

<p>For example, say you want to calculate 35^2. While you enter this into the calculator app, it is sent to the CPU behind the scenes.</p>

<p>The CPU:</p>

<ul>
  <li>takes these numbers</li>
  <li>converts them to zeros and ones</li>
  <li>calculates the result</li>
  <li>converts back to numbers</li>
  <li>renders the result on the screen: 1225.</li>
</ul>

<p>This is the basic process behind every interaction between you and your computer.</p>

<p>But these are just numbers. We don’t buy fancy computers for that. Computers use numbers so that we can see videos, images and text.</p>

<p>Videos, images and text all contain <strong>strings</strong> that need to be matched in order for us to find and use the things we want.</p>

<h2 id="efficient-string-pattern-matching-why-is-this-important">Efficient String Pattern Matching. Why is this important?</h2>

<h3 id="slow-calculation-speeds">Slow Calculation Speeds</h3>

<p>In the early ages of computing, Intel’s co-founder, Gordon E. Moore, postulated that microchips can double their transistors - and hence, their processing power - every two years.</p>

<p>Following this principle, computers today are faster than those those 42 years ago by a magnitude of 2^21. Think of your computer being more than two million times slower back in 1977!</p>

<p>To speed things up, computer scientists search for optimizations on the software side.</p>

<h3 id="software-deals-with-algorithms-but-what-is-an-algorithm">Software deals with <em>Algorithms</em>. But what is an Algorithm?</h3>

<p>For our purposes, an algorithm is a “step-by-step procedure for performing some task in a finite amount of time.” (Goodrich) Note the words “step-by-step” and “finite”.</p>

<p>Check out the <em>Further Reading</em> for a detailed explanation.</p>

<h3 id="why-more-efficient-algorithms">Why More Efficient Algorithms?</h3>

<p>We can drive a car that goes fifty miles an hour, or one that goes a hundred. But if we can get from work to home in twenty miles via the freeway, why would we take a local route with eighty miles, or five hundred?</p>

<p>Computer Scientists constantly search for algorithms that can do the same task with less time or resources. Time and money are important!</p>

<h3 id="speed-of-algorithms">Speed of Algorithms</h3>

<p>We can benchmark an algorithm by recording the time it takes to run.</p>

<p>However, computer scientists generally conduct a mathematical analysis of algorithms as a <strong>function of input size.</strong></p>

<p>All algorithms run at a speed dependent on the size of the input. Running times are characterized by that speed, which is called the algorithm’s <strong>time complexity</strong>.</p>

<h3 id="time-compexity-how-long-will-it-take">Time Compexity: how long will it take?</h3>

<p>Here are several common growth rates:</p>

<ul>
  <li>Constant</li>
  <li>Logarithm</li>
  <li>Linear</li>
  <li>N-log-N</li>
  <li>Quadratic</li>
  <li>Exponential</li>
</ul>

<p>With linear time algorithms, every time you increase the amount of data to be processed, the algorithm slows down by a proportional amount.</p>

<p>However, when algorithms are quadratic time, the speed slows quadratically, like Moore’s law - 1, 2, 4, 8, 16, 32 times slower. Double your input 21 times, and it’ll be two million times slower!</p>

<p><br /></p>
<center>
       <img src="/images/explainer/growth_rate_picture.png" />
   </center>
<p><br /></p>

<p>Crash course over! You now know the fundamentals of <strong>Computer Science</strong>. Now take a deep breath, because very soon, you’ll be telling your friends about…</p>

<h2 id="string-search-algorithms">String Search Algorithms</h2>

<h3 id="how-do-computers-find-text-in-a-larger-string">How do computers find text in a larger string?</h3>

<p>If we look at a text in a foreign language, we can reasonably deduce that we cannot find a string of English characters in there. But computers don’t have such an intuition. Matching needs to be done at each possible index.</p>

<p>In the past, the most common way of implementing a string search function was to use a “brute-force” algorithm.</p>

<h3 id="how-brute-force-works-hint-very-slowly">How Brute Force works (hint: very slowly)</h3>

<p><br /></p>
<center>
       <img src="/images/explainer/brute_force.PNG" />
   </center>
<p><br /></p>

<p>The “brute force” method is to simply try at every single index, going through the <em>whole string</em> until you find a match or assert that there is no match.</p>

<p>With a pattern of 10 characters and a string of 100 characters to match, 90 different locations need to be analyzed, up to 10 times through the string at each point, to see if you have a match.</p>

<p>Brute-force slows with quadratic time complexity, rendering it impractical for all but the smallest or most trivial tasks.</p>

<h3 id="a-better-way">A better way?</h3>

<p>Is there a certain intuition that computers can understand to take some shortcuts?</p>

<p>As it turns out, there is!</p>

<h2 id="algorithm-1-boyer-moore">Algorithm #1: Boyer-Moore</h2>

<h4 id="case-study">Case Study:</h4>

<pre><code>Match:
"Yesterday, I saw a mouse and a rat" 
In the text:
"Yesterday, I saw a mouse and a cat. Yesterday, I saw a mouse and a rat".
</code></pre>
<p><br /></p>

<p>For a computer starting from beginning, it has to match each character from “Yesterday” to “rat” and “cat”, for a total of 32 characters, including whitespace. Then, we have to go through every. single. character. again.</p>

<p>But take a look at the end of the first phrase. We immediately notice that <strong>rat</strong> and <strong>cat</strong> are not the same.</p>

<p>Your computer can do the same thing! On the 3rd index [r] and [c] do not match, and your computer only has to look at those 3 characters.</p>

<p>We call this the <strong>Looking Glass Heuristic</strong>.</p>

<p>And… now that we know that rat and cat do not match, why even bother looking at the previous characters? Simply skip forward with the <strong>Character Jump Heuristic.</strong></p>

<h4 id="together-these-form-the-boyer-moore-algorithm">Together, these form the Boyer-Moore Algorithm.</h4>

<ul>
  <li>Begin the comparisons from the end of the pattern, instead of the front.</li>
  <li>If the pattern is not contained anywhere within the string, we shift the match completely past the pattern.</li>
  <li>Otherwise, we shift until we get a character match for the mismatched character.</li>
</ul>

<p>Sounds cool? Wait until you see…</p>

<h2 id="algorithm-2-kmp">Algorithm #2: KMP</h2>

<p>One, two, three, one, two, three, one, two, three…</p>

<p>When you see patterns repeat, you know what’s coming next.</p>

<p>Likewise, computers can use repeats to skip ahead. KMP uses a “failure” function to maximize the utility of “patterns” in a pattern. That’s right, patterns in patterns.</p>

<h3 id="the-failure-function-in-kmp">The “Failure” function in KMP</h3>

<ul>
  <li>Find patterns and save them so they can be applied when a mismatch happens.</li>
  <li>The moment we have a pattern break, we immediately recognize that the whole section is not matched.</li>
  <li>Skip the whole section.</li>
</ul>

<p><br /></p>
<center>
       <img src="/images/explainer/kmp_2.PNG" width="444" height="300" />
   </center>
<p><br /></p>

<h2 id="takeaways">Takeaways:</h2>

<ul>
  <li>Boyer-Moore adds two time-saving heuristics.</li>
  <li>KMP precomputes overlaps between portions of the pattern.</li>
</ul>

<p>These breakthroughs revolutionized computer science by presenting a straightforward optimization for what, at first glance, does not have a better solution.</p>

<h2 id="so-which-one-is-better">So which one is better?</h2>

<ul>
  <li>With large alphabets, diversified texts, and longer patterns to match, Boyer-Moore is more efficient.</li>
  <li>With small alphabets, constant repeats and runs (like DNA sequences!) KMP is more efficient.</li>
  <li>Boyer-Moore is generally faster on English texts.</li>
</ul>

<h2 id="congratulations">Congratulations!</h2>

<h3 id="you-now-know-how-your-computer-works-behind-the-scenes">You now know how your computer works behind the scenes!</h3>

<p>Next time you hit CTRL + F, type and see instantaneous results, think of the journey it took to reach this stage: the nifty computer processing all those words with Boyer-Moore and KMP, and the micro-pulses that take your zeros and ones and turn them into flowing images on your screen.</p>

<hr />

<h3 id="further-reading">Further Reading:</h3>

<p>Moschovakis Y.N. (2001) What Is an Algorithm?. In: Engquist B., Schmid W. (eds) Mathematics Unlimited — 2001 and Beyond. Springer, Berlin, Heidelberg</p>

<p>Gurevich Y. (2012) What Is an Algorithm?. In: Bieliková M., Friedrich G., Gottlob G., Katzenbeisser S., Turán G. (eds) SOFSEM 2012: Theory and Practice of Computer Science. SOFSEM 2012. Lecture Notes in Computer Science, vol 7147. Springer, Berlin, Heidelberg</p>

<h3 id="bibliography">Bibliography:</h3>

<p>Boyer, Robert S. and Moore, J Strother. “A Fast String Searching Algorithm”. Palo Alto: Xerox, Palo Alto Research Center, 1976. Print.</p>

<p>Faro S., Lecroq T. “An Efficient Matching Algorithm for Encoded DNA Sequences and Binary Strings.” In: Kucherov G., Ukkonen E. (eds) Combinatorial Pattern Matching. CPM 2009. Lecture Notes in Computer Science, vol 5577. Springer, Berlin, Heidelberg: 2009.</p>

<p>Nsira, Nadia &amp; Lecroq, Thierry &amp; Elloumi, Mourad. (2015). “A fast Boyer-Moore type pattern matching algorithm for highly similar sequences.” International Journal of Data Mining and Bioinformatics. 13. 266-288. 10.1504/IJDMB.2015.072101.</p>

<p>Goodrich, Michael T., Tamassia, Roberto, and Goldwasser, Michael H. “Data Structures and Algorithms in Python”:(1st ed.). Wiley Publishing: 2013. Print.</p>

<p>Knuth, Donald E., Morris, James H. and Pratt, Vaughan R.. “Fast Pattern Matching in Strings.” SIAM Journal on Computing 6 , no. 2 (1977): 323-350.</p>

<h3 id="extra-boyer-moore-implementation-in-python">EXTRA: Boyer-Moore Implementation in Python</h3>

<p>Know how to code? Check out this implementation!
<br /></p>
<center>
       <img src="/images/explainer/boyer_moore_code.png" width="500" height="320" />
   </center>
<p><br /></p>

<p><br /></p>
<center>
       <img src="/images/explainer/boyer_moore_last.PNG" width="400" height="200" />
   </center>
<p><br /></p>

  </div>

</article>

  </div>
</main>

<footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://github.com/jerodsun" target="_blank"><i class="icon icon-github"></i></a></li>
  <li><a href="mailto:jerod.sun@live.com" target="_blank"><i class="icon icon-mail"></i></a></li>
  <li><a href="https://linkedin.com/in/jerodsun" target="_blank"><i class="icon icon-linkedin"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>2024</small>
    </p>
  </div>
</footer>



</body>
</html>
